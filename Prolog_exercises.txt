Ex 1.3: search_two(Elem, List)

search_two(X, cons(X, cons(_, cons(X, _)))).
search_two(X, cons(_, T)) :- search_two(X, T).

----------------------------------------------------------------

Ex 1.4: search_anytwo(Elem, List)

search(X, cons(X, _)).
search(X, cons(_, T)) :- search (X, T).

search_anytwo(X, cons(X, T)) :- search(X, T).
search_anytwo(X, cons(_, T)) :- search_anytwo(X, T).

----------------------------------------------------------------

Ex 2.1: size(List, Size)

size(nil, zero).
size(cons(_, T), s(X)) :- size(T, X).

----------------------------------------------------------------

Ex 2.2: sum_list(List, Sum)

add(zero, Y, Y).
add(s(X), Y, s(Z)) :- add(X, Y, Z).

sum_list(nil, zero).
sum_list(cons(H, T), R) :- sum_list(T, P), add(H, P, R).

----------------------------------------------------------------

Ex 2.4: max(List, Max)

greater_or_equal(s(_), zero).
greater_or_equal(s(X), s(Y)) :- greater_or_equal(X, Y).
greater_or_equal(zero, zero).

max(nil, Max, Max).
max(cons(H, T), TempMax, Max) :-
		max(T, H, Max),
    greater_or_equal(H, TempMax).
max(cons(H, T), TempMax, Max) :-
		max(T, TempMax, Max),
    greater_or_equal(TempMax, H).

max(cons(H, T), Max) :- max(T, H, Max).

----------------------------------------------------------------

Ex 3.1: same(List1, List2)

same(nil, nil).
same(cons(H, T1), cons(H, T2)) :- same(T1, T2).

----------------------------------------------------------------

Ex 3.2: all_bigger(List1, List2)

greater(s(_), zero).
greater(s(X), s(Y)) :- greater(X, Y).

all_bigger(nil, nil).
all_bigger(cons(H1, T1), cons(H2, T2)) :-
	all_bigger(T1, T2),
	greater(H1, H2).

----------------------------------------------------------------

Ex 3.3: sublist(List1, List2)

sublist(nil, L2).
sublist(cons(H, T), L2) :-
	sublist(T, L2),
	search(H, L2).

----------------------------------------------------------------

Ex 4.2: seqR(N, List)

seqR(zero, cons(zero, nil)).
seqR(s(H), cons(s(H), T)) :- seqR(H, T).

----------------------------------------------------------------

Ex 4.3: seqR2

last(nil, X, cons(X, nil)).
last(cons(H1, T1), X, cons(H2, T2)) :- last(T1, X, T2).

seqR2(zero, nil).
seqR2(s(N), R) :-
	seqR2(N, T),
	last(T, N, R).

----------------------------------------------------------------

Ex 5.1: map(_ + 1)
% Map every Peano number of the list in s(N).
% Input => map_1(cons(zero, cons(s(zero), cons(s(s(zero)), nil))), X). ([1, 2, 3])

map_1(nil, nil).
map_1(cons(H, T), cons(s(H), R)) :- map_1(T, R).

----------------------------------------------------------------

Ex 5.2: filter(_ > 0)
% Create a new list without "zero" Peano numbers.
% Input => filter_0(cons(s(zero), cons(zero, cons(s(s(zero)), nil))), X).

filter_0(nil,nil).
filter_0(cons(H, T),cons(H, R)):-
	H \= zero,
	filter_0(T, R).
filter_0(cons(zero, T), R) :-
	filter_0(T, R).

----------------------------------------------------------------

Ex 5.3: count(_ > 0)
% Count the element of the list greater than 0.
% Input => count_0(cons(s(zero), cons(zero, cons(s(s(zero)), nil))), N).

count(L, N) :-
	count(L, zero, N).
count(nil, N, N).
count(cons(_, T), A, N) :- count(T, s(A), N).

count_0(L, N) :-
	filter_0(L, R),
	count(R, N).

----------------------------------------------------------------

Ex 5.4: find(_ > 0)
% Find the first element of the list with elements greater than 0.
% Input => find_0(X, cons(zero, cons(s(zero), cons(s(s(zero)), nil)))).

find_0(N, L) :-
	filter_0(L, R),
	search(N, R).

----------------------------------------------------------------

Ex 5.5: take(N, List, Res)
% Take the first N elements from the list.

take(zero, _, nil).
take(_, nil, nil).
take(s(N), cons(H, T), cons(H, R)) :- take(N, T, R).

----------------------------------------------------------------

Ex 5.6: drop(N, List, Res)
% Drop N elements of the list from the left.

drop(zero, L, L).
drop(_, nil, nil).
drop(s(N), cons(_, T), R) :- drop(N, T, R).

----------------------------------------------------------------

Ex 5.7: reversed(List, Res)
% Reverse the list

reversed(L, R) :- reversed(L, nil, R).
reversed(nil, A, A).
reversed(cons(H, T), A, R) :- reversed(T, cons(H, A), R).

----------------------------------------------------------------

Ex 5.8: zip(List1, List2, Res)
% Zip the elements of two lists.
% Input => zip(cons(1, cons(2, nil)), cons(a, cons(b, nil)), R).

zip(nil, _, nil).
zip(_, nil, nil).
zip(cons(H1, T1), cons(H2, T2), cons(pair(H1, H2), R)) :- zip(T1, T2, R).

----------------------------------------------------------------

Ex 5.9: dropWhile(List, Res)

% Drop all the element not equal to zero until finds the first zero (if it exists).
% Inputs: => dropWhile(cons(s(zero), cons(s(s(zero)), cons(zero, cons(s(zero), nil)))), R).
	     dropWhile(cons(s(zero), cons(s(zero), nil)), R). (All elements dropped)
	     dropWhile(cons(zero, cons(s(zero), cons(zero, nil))), R). (No element dropped)

dropWhile(nil, nil).
dropWhile(cons(zero, T), cons(zero, T)).
dropWhile(cons(H, T), R) :-
	H \= zero,
	dropWhile(T, R).

----------------------------------------------------------------

Ex 5.10: dropRight(N, List, Res)
% Drop N elements from the right of the list.
% Inputs => dropRight(s(s(zero)), cons(a, cons(b, cons(c, cons(d, nil)))), R).
	    dropRight(s(s(s(s(zero)))), cons(a, cons(b, cons(c, cons(d, nil)))), R).

sub(N, zero, N).
sub(s(N), s(M), R) :- sub(N, M, R).
dropRight(N, L, R) :-
	size(L, S),
	sub(S, N, NTake),
	take(NTake, L, R).
